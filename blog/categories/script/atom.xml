<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: script | Aaron Kromer's Blog]]></title>
  <link href="http://cupakromer.github.com/blog/categories/script/atom.xml" rel="self"/>
  <link href="http://cupakromer.github.com/"/>
  <updated>2014-03-17T17:57:43-04:00</updated>
  <id>http://cupakromer.github.com/</id>
  <author>
    <name><![CDATA[Aaron Kromer]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ignite Those Horrible Scripts]]></title>
    <link href="http://cupakromer.github.com/blog/2014-02-24-ignite-those-horrible-scripts.html"/>
    <updated>2014-02-24T11:03:00-05:00</updated>
    <id>http://cupakromer.github.com/blog/ignite-those-horrible-scripts</id>
    <content type="html"><![CDATA[<p>The past week was spent dealing with an infuriating data crunching task.
<a href="https://twitter.com/crsexton">Chris</a> and I decided to celebrate by killing our
poorly written Ruby cli scripts with fire. Printing the scripts and going out
back to set them on fire would be more dramatic. Though it probably would be
appreciated by the other businesses which we share space with.</p>

<p>I took a breather and looked into <a href="http://www.zsh.org/">zsh</a> functions to
accomplish this. Here's what I came up with:</p>

<p><code>``sh
rageflip() { echo " ‚îª‚îÅ‚îª Ô∏µ„ÉΩ(\</code>–î¬¥)ÔæâÔ∏µ ‚îª‚îÅ‚îª  $*" }</p>

<p>has_utility() { hash $1 2>/dev/null }</p>

<h1>Wrapper around <code>rm -rf</code> expressing callers loathing and disdain for the</h1>

<h1>provided files.</h1>

<p>#</p>

<h1>Inspiration was Homebrew's output:</h1>

<h1>üç∫  /usr/local/Cellar/tmux/1.9: 15 files, 628K, built in 25 seconds</h1>

<p>#</p>

<h1>For additional file stats, specific to code files, consider installing the</h1>

<h1>Count Lines of Code (cloc) tool: http://cloc.sourceforge.net/</h1>

<p>#</p>

<h1>brew install cloc</h1>

<h1>sudo apt-get install cloc</h1>

<p>#
ignite() {
  if (( $# == 0 )) then echo "USAGE: ignite file [file] ..."; return; fi
  local total_lines
  local human_size
  local lc_blank
  local lc_comment
  local lc_code
  echo "BURN IT ALL!!! $(rageflip)"
  for i do</p>

<pre><code># If the file is empty we have 0 lines
human_size=$(ls -lh $i | awk '{ print $5 }')
total_lines=${$(sed -n '$=' $i):-0}
stats="$total_lines lines"

if has_utility cloc; then
  # Setup some local variables regarding file stats
  lc_blank=
  lc_comment=
  lc_code=
  eval $(
    cloc $i --quiet | tail -2 | head -1 |
    awk '{ print "lc_blank="$3, "lc_comment="$4, "lc_code="$5 }'
  )
  if [ ! -z $lc_blank ]; then
    stats="$lc_code loc, $lc_comment comments, $lc_blank whitespace lines"
  fi
fi

rm -rf $i
echo "üî•  $i: $stats, $human_size"
</code></pre>

<p>  done
}
```</p>

<p>Now we can sit back and watch it all burn:</p>

<p><code>sh
$ ignite script/crunch-*
BURN IT ALL!!!  ‚îª‚îÅ‚îª Ô∏µ„ÉΩ(`–î¬¥)ÔæâÔ∏µ ‚îª‚îÅ‚îª
üî•  script/crunch-dump-sessions: 5 loc, 5 comments, 2 whitespace lines, 330B
üî•  script/crunch-normalize: 47 loc, 14 comments, 11 whitespace lines, 2.2K
üî•  script/crunch-import-csv: 101 loc, 2 comments, 20 whitespace lines, 2.7K
üî•  script/crunch-timestamp: 203 loc, 44 comments, 38 whitespace lines, 8.4K
</code></p>

<p>Though at this point, it might as well be a full script file. If I do that, I
might as well just write it as a Ruby cli...</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pitfalls of Testing Scripts With Load - Part 2]]></title>
    <link href="http://cupakromer.github.com/blog/2014-02-17-pitfalls-of-testing-scripts-with-load-part-2.html"/>
    <updated>2014-02-17T10:15:00-05:00</updated>
    <id>http://cupakromer.github.com/blog/pitfalls-of-testing-scripts-with-load-part-2</id>
    <content type="html"><![CDATA[<p>File /Users/aaron/dev/cupakromer/cupakromer.github.com/source/<em>posts/</em>pitfalls_of_test_load_posts.md could not be found</p>

<h2>Scope Smashing</h2>

<p>Take the following script and spec:</p>

<p>```ruby</p>

<h1>!/usr/bin/env ruby</h1>

<p>def current_user
  'Bob'
end
```</p>

<p>```ruby
require 'spec_helper'</p>

<p>def current_user
  'Alice'
end</p>

<p>describe 'Running the server locally' do
  it 'logs that it is running' do</p>

<pre><code>load 'script/current-user-smash'

expect(current_user).to eq 'Alice'
</code></pre>

<p>  end
end
```</p>

<p>Alas, the spec fails with:</p>

<p>```
expected: "Alice"</p>

<pre><code> got: "Bob"
</code></pre>

<p>```</p>

<p>This is due to how <a href="http://ruby-doc.org/core-2.1.0/Kernel.html#method-i-load"><code>load</code></a> works:</p>

<blockquote><p>If the optional <code>wrap</code> parameter is <code>true</code>, the loaded script will be
executed under an anonymous module, protecting the calling program‚Äôs global
namespace. In no circumstance will any local variables in the loaded file be
propagated to the loading environment.</p></blockquote>

<p>While it is easy to spot the issue this time, that's not normally the case.
Say if the additional method is define by a gem or in supporting file. Or if
you are testing multiple scripts that each define the same top-level methods.
These conditions will result in very strange and difficult to debug failures.
Of course, it's always a good idea to not define top-level methods to begin
with.</p>

<p>Instead always pass the additional <code>wrap</code> parameter. Here I've named it as a
descriptive inline variable to reveal it's intent:</p>

<p>```ruby
it 'logs that it is running' do
  load 'script/current-user-smash', _in_sandbox = true</p>

<p>  expect(current_user).to eq 'Alice'
end
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pitfalls of Testing Scripts With Load - Part 1]]></title>
    <link href="http://cupakromer.github.com/blog/2013-07-29-pitfalls-of-testing-scripts-with-load-part-1.html"/>
    <updated>2013-07-29T13:29:00-04:00</updated>
    <id>http://cupakromer.github.com/blog/pitfalls-of-testing-scripts-with-load-part-1</id>
    <content type="html"><![CDATA[<p>File /Users/aaron/dev/cupakromer/cupakromer.github.com/source/<em>posts/</em>pitfalls_of_test_load_posts.md could not be found</p>

<p>Previously it was shown how to <a href="http://aaronkromer.com/blog/2013-07-11-testing-scripts-with-load.html">use load to test scripts</a>. As with all techniques, there are some drawbacks to using <code>load</code>.</p>

<h2>Hidden Require Dependency</h2>

<p>Take script:</p>

<p>```ruby</p>

<h1>!/usr/bin/env ruby</h1>

<p>$:.unshift File.join File.dirname(<strong>FILE</strong>), "..", "lib"</p>

<p>require 'local_server'</p>

<p>logger = Logger.new($stderr)</p>

<p>LocalServer.new(logger).run
```</p>

<p>and passing spec:</p>

<p>```ruby
require 'spec_helper'
require 'logger'
require 'stringio'</p>

<p>describe 'Running the server locally' do
  it 'logs that it is running' do</p>

<pre><code>io = StringIO.new
allow(Logger).to receive(:new).and_return(Logger.new io)

expect{ load 'script/local-server' }.to change{ io.string }
  .to include 'SERVER: starting up'
</code></pre>

<p>  end
end
```</p>

<p>However, when the script is run standalone, it errors with:</p>

<p><code>
uninitialized constant Logger (NameError)
</code></p>

<p>Be aware that since <a href="http://ruby-doc.org/core-2.0/Kernel.html#method-i-load"><code>load</code></a>
happens in the current spec context, a missing <code>require</code> may not be noticed if
it is required by the spec.</p>

<p>Whenever possible have at least one test that shells out as a sanity check.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing Scripts with Load]]></title>
    <link href="http://cupakromer.github.com/blog/2013-07-11-testing-scripts-with-load.html"/>
    <updated>2013-07-11T12:44:00-04:00</updated>
    <id>http://cupakromer.github.com/blog/testing-scripts-with-load</id>
    <content type="html"><![CDATA[<p>File /Users/aaron/dev/cupakromer/cupakromer.github.com/source/<em>posts/</em>pitfalls_of_test_load_posts.md could not be found</p>

<p>A standard method for testing Ruby scripts is to shell out to the script using
<a href="http://ruby-doc.org/core-2.0/Kernel.html#method-i-60"><code>Kernel#`</code></a>
or <a href="http://ruby-doc.org/core-2.0/Kernel.html#method-i-system"><code>Kernel#system</code></a>.
Both of these follow a <a href="http://ruby-doc.org/core-2.0/Kernel.html#method-i-fork"><code>fork</code></a>
and <a href="http://ruby-doc.org/core-2.0/Kernel.html#method-i-exec"><code>exec</code></a> pattern to
run the command.</p>

<p>However, there are instances where it is necessary to mock/stub something in
the script.  The above technique fails in this situation due to <code>exec</code>
replacing the current process; the stubs simply cease to exist.</p>

<p>The solution: use <a href="http://ruby-doc.org/core-2.0/Kernel.html#method-i-load"><code>load</code></a></p>

<p>```ruby</p>

<h1>Script</h1>

<h1>!/usr/bin/env ruby</h1>

<p>$:.unshift File.join File.dirname(<strong>FILE</strong>), "..", "lib"</p>

<p>require 'logger'
require 'monitor'
require 'pathname'
require 'temperature_api'
require 'tracker'</p>

<p>logger    = Logger.new($stderr)
file_path = Pathname.new(ARGV[0])
tracker   = Tracker.new(backup: file_path)
api       = TemperatureApi.new('api.server.com')</p>

<p>Monitor.new(tracker, api, logger).run
```</p>

<p>```ruby</p>

<h1>Spec</h1>

<p>describe 'Monitoring cpu heat' do</p>

<p>  it 'uploads the temperature to the server' do</p>

<pre><code>stub_const('ARGV', ['monitor-integration.bak'])
stub_request(:put, 'https://api.server.com/temp').to_return(status: 200)

expect(load 'script/monitor')
  .to have_requested(:put, 'https://api.server.com/temp')
  .with(body: /\A{"temp":\d+}\z/)
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>In conclusion, no more excuses for not have integration tests for your scripts.</p>
]]></content>
  </entry>
  
</feed>
