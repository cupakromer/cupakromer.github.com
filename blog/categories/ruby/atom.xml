<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Aaron Kromer's Blog]]></title>
  <link href="http://cupakromer.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://cupakromer.github.com/"/>
  <updated>2013-07-30T21:48:07-04:00</updated>
  <id>http://cupakromer.github.com/</id>
  <author>
    <name><![CDATA[Aaron Kromer]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Pitfalls of Testing Scripts With Load - Part 1]]></title>
    <link href="http://cupakromer.github.com/blog/2013-07-29-pitfalls-of-testing-scripts-with-load-part-1.html"/>
    <updated>2013-07-29T13:29:00-04:00</updated>
    <id>http://cupakromer.github.com/blog/pitfalls-of-testing-scripts-with-load-part-1</id>
    <content type="html"><![CDATA[<p>Previously it was shown how to <a href="http://aaronkromer.com/blog/2013-07-11-testing-scripts-with-load.html">use load to test scripts</a>. As with all techniques, there are some drawbacks to using <code>load</code>.</p>

<h3>Hidden Require Dependency</h3>

<p>Take script:</p>

<p>```ruby</p>

<h1>!/usr/bin/env ruby</h1>

<p>$:.unshift File.join File.dirname(<strong>FILE</strong>), "..", "lib"</p>

<p>require 'local_server'</p>

<p>logger = Logger.new($stderr)</p>

<p>LocalServer.new(logger).run
```</p>

<p>and passing spec:</p>

<p>```ruby
require 'spec_helper'
require 'logger'
require 'stringio'</p>

<p>describe 'Running the server locally' do
  it 'logs that it is running' do</p>

<pre><code>io = StringIO.new
allow(Logger).to receive(:new).and_return(Logger.new io)

expect{ load 'script/local-server' }.to change{ io.string }
  .to include 'SERVER: starting up'
</code></pre>

<p>  end
end
```</p>

<p>However, when the script is run standalone, it errors with:</p>

<p><code>
uninitialized constant Logger (NameError)
</code></p>

<p>Be aware that since <a href="http://ruby-doc.org/core-2.0/Kernel.html#method-i-load"><code>load</code></a>
happens in the current spec context, a missing <code>require</code> may not be noticed if
it is required by the spec.</p>

<p>Whenever possible have at least one test that shells out as a sanity check.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Monitoring Specific Messages in RSpec Part 3]]></title>
    <link href="http://cupakromer.github.com/blog/2013-07-26-monitoring-specific-messages-in-rspec-part-3.html"/>
    <updated>2013-07-26T10:13:00-04:00</updated>
    <id>http://cupakromer.github.com/blog/monitoring-specific-messages-in-rspec-part-3</id>
    <content type="html"><![CDATA[<p>Continuing the series (
<a href="http://aaronkromer.com/blog/2013-07-17-monitoring-specific-messages-in-rspec.html">part 1</a>,
<a href="http://aaronkromer.com/blog/2013-07-24-monitoring-specific-messages-in-rspec-part-2.html">part 2</a>
) on matching messages in RSpec, the next logical step is custom argument
matchers.</p>

<p><code>ruby
expect(mechanic).to receive(:fix).with something_broken
</code></p>

<p>Using the RSpec <a href="https://www.relishapp.com/rspec/rspec-expectations/v/2-14/docs/custom-matchers">matcher DSL</a>
this could simply look like:</p>

<p>```ruby
RSpec::Matchers.define :something_broken do
  match do |thing|</p>

<pre><code>thing.broken?
</code></pre>

<p>  end
end
```</p>

<p>That's all there is to it. Now it can be used as both a regular matcher and as
an argument matcher.</p>

<p>If the matcher needs to be created from
<a href="http://rubydoc.info/gems/rspec-expectations/RSpec/Matchers">scratch</a>, a
<code>matches?</code> method must be defined instead:</p>

<p>```ruby
class SomethingBroken
  def matches?(target)</p>

<pre><code>target.broken?
</code></pre>

<p>  end
end</p>

<p>def something_broken
  SomethingBroken.new
end
```</p>

<p>This works just fine as a normal matcher, however, when used as an argument
matcher, it will always fail. The reason is that argument matchers are invoked
with the <code>==</code> operator, which by <a href="http://ruby-doc.org/core-2.0/BasicObject.html#method-i-3D-3D">default</a>,
verifies if the objects are the same object.</p>

<p>Attempting to use a normal matcher with the
<a href="https://www.relishapp.com/rspec/rspec-expectations/v/2-14/docs/built-in-matchers/expect-change"><code>change</code></a>
expectation also
<a href="https://github.com/rspec/rspec-expectations/issues/276">oddly</a> fails, due to
<code>change</code> invoking the
<a href="http://aaronkromer.com/blog/2012-10-12-equals-equals-equals-the-forgotten-equality.html"><code>===</code></a>
message, not <code>matches?</code>. Since the <a href="http://ruby-doc.org/core-2.0/Object.html#method-i-3D-3D-3D">default <code>===</code> behavior is
<code>==</code></a>, the existing
argument matchers currently work with it.</p>

<p>There is active talk / changes
<a href="https://github.com/rspec/rspec-expectations/issues/280">happening</a> to
standardize the matchers to <code>===</code>. This will allow for a more consistent and
composable interface. It also has the added benefit of allowing the matchers to
be used in more complex conditionals using <code>case</code> statements.</p>

<p>To fix the class based matcher simply add the necessary alias(es):</p>

<p>```ruby
class SomethingBroken
  def matches?(target)</p>

<pre><code>target.broken?
</code></pre>

<p>  end
  alias_method :==, :matches?
  alias_method :===, :matches?  # Not technically necessary due to default ==
end
```</p>

<p>Note that with such a simple matcher, there is no reason it cannot be created
as a simple composed method using an existing matcher:</p>

<p><code>ruby
def something_broken
  be_broken   # Note: Not all built in matchers have == aliases yet
end
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Monitoring Specific Messages in RSpec Part 2]]></title>
    <link href="http://cupakromer.github.com/blog/2013-07-24-monitoring-specific-messages-in-rspec-part-2.html"/>
    <updated>2013-07-24T10:11:00-04:00</updated>
    <id>http://cupakromer.github.com/blog/monitoring-specific-messages-in-rspec-part-2</id>
    <content type="html"><![CDATA[<p><a href="http://aaronkromer.com/blog/2013-07-17-monitoring-specific-messages-in-rspec.html">Last time</a> it was demonstrated how it is possible to monitor only a desired
message expectations. While that technique is useful for a vast majority of
use cases, sometimes you need a bit more complexity.</p>

<p>Say for example, the desire is to verify the state of the provided parameter.
As in this very contrived example (<em>Update: 2013-07-28 Paired down example to
only show test and not implementation</em>):</p>

<p>```ruby
describe Factory do
  context 'making sure current stock is ready' do</p>

<pre><code>it 'only fixes broken widgets' do
  # Setup code

  states = []
  expect(mechanic).to receive(:fix) do |widget|
    states &lt;&lt; widget.broken?
  end

  expect{ factory.perform_maintenance }.to change{states}.to [true]
end
</code></pre>

<p>  end
end
```</p>

<p>This leverages the <a href="https://www.relishapp.com/rspec/rspec-mocks/v/2-14/docs/method-stubs/stub-with-substitute-implementation">stub with substitute implementation</a>
provided by RSpec mocks. It can also be used with the <code>allow</code> syntax.</p>

<p>While the above version has it's uses, it tends to hide some of the intent in
the closure manipulation. A slightly more expressive method is just to add
the state expectation in the block:</p>

<p><code>ruby
expect(mechanic).to receive(:fix) do |widget|
  expect(widget).to be_broken
end
</code></p>

<p>This last technique is great for setting up generic message stubs which require
that something with specific state is provided. By adding it to a generic
<code>allow</code>, it ensures when the contract is broken anywhere in the code under test,
the test will properly fail. (<em>Update 2013-07-30: seems there is an
<a href="https://github.com/rspec/rspec-mocks/pull/382">issue</a> with this technique when
combined with
<a href="https://www.relishapp.com/rspec/rspec-mocks/v/2-14/docs/message-expectations/calling-the-original-method"><code>and_call_original</code></a></em>)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Monitoring Specific Messages in RSpec]]></title>
    <link href="http://cupakromer.github.com/blog/2013-07-17-monitoring-specific-messages-in-rspec.html"/>
    <updated>2013-07-17T11:34:00-04:00</updated>
    <id>http://cupakromer.github.com/blog/monitoring-specific-messages-in-rspec</id>
    <content type="html"><![CDATA[<p>A common question I see asked in the #rspec IRC channel is:</p>

<blockquote><p>How do I verify only a specific message is received?</p></blockquote>

<p>The context of this question is usually a method that sends the same message
multiple time, but with different arguments.</p>

<p>Take the following contrived example:</p>

<p>```ruby
def do_stuff(thing)
  thing.do :having_fun
  thing.do :drink_coffee
  thing.do :code
end</p>

<p>describe 'Coffee time!' do
  it 'drinks the coffee' do</p>

<pre><code>thing = double('Thing')

expect(thing).to receive(:do).with(:drink_coffee)

do_stuff thing
</code></pre>

<p>  end
end
```</p>

<p>Alas, it fails:</p>

<p>```text
Double "Thing" received :do with unexpected arguments</p>

<pre><code>     expected: (:drink_coffee)
          got: (:having_fun)
</code></pre>

<p>```</p>

<p>The solution is to add a generic stub (a catchall) for the desired message:</p>

<p>```ruby
describe 'Coffee time!' do
  it 'drinks the coffee' do</p>

<pre><code>thing = double('Thing')

allow(thing).to receive(:do)
expect(thing).to receive(:do).with(:drink_coffee)

do_stuff thing
</code></pre>

<p>  end
end
```</p>

<p>There is another solution which can also be used:
<a href="https://www.relishapp.com/rspec/rspec-mocks/v/2-14/docs/method-stubs/as-null-object"><code>as_null_object</code></a>.</p>

<p>The issue with <code>as_null_object</code> is that it will happily hum along even for
invalid and unexpected messages. The double stub pattern above is
explicit in the test, matching the catchall only with the message expectation.</p>

<p>```ruby
describe 'Coffee time!' do
  it 'drinks the coffee' do</p>

<pre><code>thing = double('Thing').as_null_object

expect(thing).to receive(:do).with(:drink_coffee)

do_stuff thing
</code></pre>

<p>  end
end
```</p>

<p>Stay tuned for <a href="http://myronmars.to/n/dev-blog/2013/07/the-plan-for-rspec-3">RSpec3</a>
when <code>as_null_object</code> doubles will be smart enough to only stub matching
messages.  Or check out one of the many plugins:
<a href="https://github.com/xaviershay/rspec-fire"><code>rspec-fire</code></a>,
<a href="https://github.com/psyho/bogus"><code>bogus</code></a>, and
<a href="https://github.com/ryanong/spy"><code>spy</code></a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing Scripts with Load]]></title>
    <link href="http://cupakromer.github.com/blog/2013-07-11-testing-scripts-with-load.html"/>
    <updated>2013-07-11T12:44:00-04:00</updated>
    <id>http://cupakromer.github.com/blog/testing-scripts-with-load</id>
    <content type="html"><![CDATA[<p>A standard method for testing Ruby scripts is to shell out to the script using
<a href="http://ruby-doc.org/core-2.0/Kernel.html#method-i-60"><code>Kernel#`</code></a>
or <a href="http://ruby-doc.org/core-2.0/Kernel.html#method-i-system"><code>Kernel#system</code></a>.
Both of these follow a <a href="http://ruby-doc.org/core-2.0/Kernel.html#method-i-fork"><code>fork</code></a>
and <a href="http://ruby-doc.org/core-2.0/Kernel.html#method-i-exec"><code>exec</code></a> pattern to
run the command.</p>

<p>However, there are instances where it is necessary to mock/stub something in
the script.  The above technique fails in this situation due to <code>exec</code>
replacing the current process; the stubs simply cease to exist.</p>

<p>The solution: use <a href="http://ruby-doc.org/core-2.0/Kernel.html#method-i-load"><code>load</code></a></p>

<p>```ruby</p>

<h1>Script</h1>

<h1>!/usr/bin/env ruby</h1>

<p>$:.unshift File.join File.dirname(<strong>FILE</strong>), "..", "lib"</p>

<p>require 'logger'
require 'monitor'
require 'pathname'
require 'temperature_api'
require 'tracker'</p>

<p>logger    = Logger.new($stderr)
file_path = Pathname.new(ARGV[0])
tracker   = Tracker.new(backup: file_path)
api       = TemperatureApi.new('api.server.com')</p>

<p>Monitor.new(tracker, api, logger).run
```</p>

<p>```ruby</p>

<h1>Spec</h1>

<p>describe 'Monitoring cpu heat' do</p>

<p>  it 'uploads the temperature to the server' do</p>

<pre><code>stub_const('ARGV', ['monitor-integration.bak'])
stub_request(:put, 'https://api.server.com/temp').to_return(status: 200)

expect(load 'script/monitor')
  .to have_requested(:put, 'https://api.server.com/temp')
  .with(body: /\A{"temp":\d+}\z/)
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>In conclusion, no more excuses for not have integration tests for your scripts.</p>
]]></content>
  </entry>
  
</feed>
