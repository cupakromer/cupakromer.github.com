<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Aaron Kromer's Blog]]></title>
  <link href="http://cupakromer.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://cupakromer.github.com/"/>
  <updated>2013-05-02T21:20:12-04:00</updated>
  <id>http://cupakromer.github.com/</id>
  <author>
    <name><![CDATA[Aaron Kromer]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How Basic RSpec Works - Simplified]]></title>
    <link href="http://cupakromer.github.com/blog/2012-12-09-how-basic-rspec-works-simplified.html"/>
    <updated>2012-12-09T20:15:00-05:00</updated>
    <id>http://cupakromer.github.com/blog/how-basic-rspec-works-simplified</id>
    <content type="html"><![CDATA[<p>Recently, I had the privilege of giving a talk regarding
<a href="http://rspec.info">RSpec</a> at the
<a href="http://www.meetup.com/Arlington-Ruby/">Arlington Ruby</a> meetup group.
The talk was about RSpec and how you can take some next steps with it
(slides here: <a href="http://rspec-next-steps.herokuapp.com">http://rspec-next-steps.herokuapp.com</a>.</p>

<p>The talk was targeted at intermediate RSpec users. There were several in
attendance whom were fairly new to RSpec. This made some of the talk
seem like "magic". Based on the questions I received, I wanted to take a
moment to address some of the general workings of RSpec, in order to
dispel any "magic" that may seem to be happening.</p>

<p>It is my hope to try to show how <em>some</em> of this works. I won't be
covering any of the more advanced topics just yet, as the code can get a
bit complicated, and the point here is to simplify how RSpec works. So
bare with me and the overly simplistic implementation. The full code is
available in the following GitHub gist:
<a href="https://gist.github.com/4247624">https://gist.github.com/4247624</a></p>

<p>First, we need to setup some methods that define the basic usage of
RSpec: <code>describe</code>, <code>subject</code>, <code>before</code>, <code>after</code>, and <code>it</code>.</p>

<p>First up is the outer <code>describe</code>:</p>

<p><code>ruby
def describe(object_under_test, &amp;block)
  @obj_under_test = object_under_test
  @test_group     = block
end
</code></p>

<p>In this example we are specifically only supporting a single <code>describe</code>
block with no nesting. The reason here is for simplicity.  In our case
<code>describe</code> is just a method that takes an object or description string
and block. Nothing special. Hopefully, this helps make it clear that we
are only dealing with a DSL for creating / setting up examples. We'll
store away the test object in an instance variable and keep a reference
to the block for later.</p>

<p>Next, we setup a method for gaining access to subject:</p>

<p>```ruby
def subject
  if @obj_under_test.is_a? Class</p>

<pre><code>@subject ||= @obj_under_test.new
</code></pre>

<p>  else</p>

<pre><code>@obj_under_test
</code></pre>

<p>  end
end
```</p>

<p>If our subject is a <code>class</code>, we create a new memoized instance of it.
Otherwise, we simply return the object itself.</p>

<p>Next is the commonly used <code>before</code> blocks and the associated <code>after</code>
friend:</p>

<p><code>ruby
def before(&amp;block) @before_hooks &lt;&lt; block end
def after(&amp;block)  @after_hooks  &lt;&lt; block end
</code></p>

<p>In this simplistic implementation, it is easy to see how they work. We
just keep a reference to all of the block in a normal array (in Ruby the
order of insertion is preserved) for use later. We do the same with
<code>after</code>.</p>

<p>Last up, is the real meat of the examples, the <code>it</code> block:</p>

<p>```ruby
def it(description = nil, &amp;block)
  @examples &lt;&lt; Example.new(description, block)
end</p>

<p>Example = Struct.new(:description, :test) do
  attr_accessor :result, :failure
  def call</p>

<pre><code>@result = if test
            begin
              test.call
              :passed
            rescue =&gt; e
              @failure = e
              :failed
            end
          else
            :pending
          end
</code></pre>

<p>  end
end
```</p>

<p>As with the <code>describe</code> method, this takes an optional description and a
block to execute (our actual test). We'll need access to both of these
later, and we'll have multiple examples, so we'll use a simple object to
keep track of each.  After creating the example object, we'll store it
in the queue.</p>

<p>At this point it is worth taking a moment to discuss <code>Example#call</code>. We
named it <code>call</code> so that accessing it is no different than a traditional
block. This makes it easier to change code later.</p>

<p>Inside <code>Example#call</code>, we attempt to pass <code>call</code> on the block that the
<code>Example</code> was created with. If this raises an error, we store the
exception for access later and mark the test as <code>failed</code>. Something to
note here is that the return value of the <code>test</code> block is ignored. A
test is marked as <code>passed</code> as long as it does not <code>raise</code> any errors.
This is also how RSpec behaves.</p>

<p>If no block was given when we created the <code>Example</code>, then we treat it as
<code>pending</code>.  I have omitted the <code>pending</code> method, common in RSpec due to
the complexity it would add to this example.</p>

<p>Something else to note, since this is an overly simplistic example, we
are doing everything in the global main namespace. RSpec does <em>not</em>
behave this way, but it helps keep our example simple. Due to this,
we'll need to setup some of our variables:</p>

<p><code>ruby
@before_hooks = []
@after_hooks  = []
@examples     = []
</code></p>

<p>Additionally, we don't have any matchers defined yet. To keep it simple,
I'll add a TestUnit style <code>assert</code> matcher.</p>

<p><code>ruby
def assert(truthy)
  truthy or raise Error.new("Test failed.")
end
</code></p>

<p>At this point, I hope you can start to get the picture of how our
simplified example will run.  We'll setup our <code>run</code> as follows:</p>

<p>```ruby
def run
  raise 'No object under test defined.' unless @obj_under_test</p>

<p>  puts @obj_under_test
  return unless @test_group</p>

<p>  # Find out what tests need to be run
  @test_group.call</p>

<p>  # Run the tests
  @examples.each_with_index do |example, index|</p>

<pre><code>@subject = nil
puts "\n\nEXAMPLE #{index+1}:"
begin
  @before_hooks.each(&amp;:call)
  example.call
  puts "\n    #{example.description} =&gt; #{example.result.upcase}\n"
rescue =&gt; e
  puts "\n    #{example.description} =&gt; failed\n"
ensure
  @after_hooks.reverse_each(&amp;:call)
end
</code></pre>

<p>  end
end
```</p>

<p>If there is no object under test defined when we <code>run</code> (i.e. <code>describe</code>
was never called) then we raise an error. Otherwise, we output the
object under test. If this is a <code>class</code> (as is usual for a top level
<code>describe</code> block) then we will see the class name. Otherwise, the object
itself is output.  If it is a string, we'll get the string value,
otherwise, we'll get the object's <code>#to_s</code> representation.</p>

<p><em>It should be noted that in the real RSpec this outputting is much more
complicated and left up to various output formatters.</em></p>

<p>Next we will run the <code>test_group</code> (the body of the <code>describe</code> block). This
in turn call all our <code>before</code>, <code>after</code>, and <code>it</code> methods, which set up our
environment and define the examples.</p>

<p>All that is left, is to iterate over the examples and run them. Here I'm
using <code>each_with_index</code> solely to be able to add some debugging output
to make it a bit clearer how things are running. Normally, this would be
a simple <code>each</code> iterator.</p>

<p>Before each test run, we make sure we have a new empty <code>subject</code>. We
then iterate through each of the <code>before</code> blocks in the order they were
defined. At this point we run the example. After the example runs, I'm
immediately
outputting the results to keep things simple. In the real RSpec, this is
handled by an output formatter. Finally, all of the <code>after</code> hooks are
run, but in reverse defined order.</p>

<p>It should be noted, that here, as in the real RSpec, if any of the
<code>before</code> blocks throw an exception the test fails. However, failures in
any <code>after</code> block are ignored.</p>

<p>That's it. We can then use this to define our sample spec:</p>

<p>```ruby
class Thing
  attr_reader :my_value
  def initialize</p>

<pre><code>@my_value = rand 5
</code></pre>

<p>  end
end</p>

<p>describe Thing do
  before { puts "BEFORE_BLOCK:: First before block" }
  after do</p>

<pre><code>print "AFTER_BLOCK:: should be called last!"
print "    Reset @tmp_value(#{@tmp_value.inspect}) =&gt; "
@tmp_value = nil
puts "@tmp_value(#{@tmp_value.inspect})"
</code></pre>

<p>  end</p>

<p>  it 'has access to subject' do</p>

<pre><code>p subject
assert subject.my_value &lt; 5
</code></pre>

<p>  end</p>

<p>  it 'subject changes only between tests' do</p>

<pre><code>p subject
assert subject.equal?(subject)
</code></pre>

<p>  end</p>

<p>  it "fails on error" do</p>

<pre><code>raise Error.new 'Sad face'
</code></pre>

<p>  end</p>

<p>  it 'works!' do</p>

<pre><code>assert @tmp_value == 'test'
</code></pre>

<p>  end</p>

<p>  before do</p>

<pre><code>@tmp_value = 'test'
print "BEFORE_BLOCK:: Another before block"
puts "     Set @tmp_value(#{@tmp_value.inspect})"
</code></pre>

<p>  end</p>

<p>  it 'is pending'</p>

<p>  after { puts "AFTER_BLOCK:: should be called first!!" }
end
```</p>

<p>I hope it is clear how this spec will end up running. This is not
exactly equivalent to how RSpec will treat things (notice that we need
to explicitly clear <code>@tmp_value</code> in an <code>after</code> block, where RSpec will
do that for us). This is due to how RSpec creates example classses
(which we are not using) and how it binds the blocks to different
scopes; we are strictly using the <code>global</code> namespace to keep the example
simple.</p>

<p>Check out the gist for the code and output of the sample spec:
<a href="http://gist.github.com/4247624">http://gist.github.com/4247624</a></p>

<p>Stay tuned for more on RSpec in the future.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[=== the Forgotten Equality]]></title>
    <link href="http://cupakromer.github.com/blog/2012-10-12-equals-equals-equals-the-forgotten-equality.html"/>
    <updated>2012-10-12T19:04:00-04:00</updated>
    <id>http://cupakromer.github.com/blog/equals-equals-equals-the-forgotten-equality</id>
    <content type="html"><![CDATA[<p>Recently I was looking for a way to do a comparison on a <code>String</code> with
either another <code>String</code> or a <code>Regexp</code>. Most of the discussions on equality
focused on <code>==</code>, <code>eql?</code>, <code>equal?</code>. None of which would satisfy the requirement.
So I was left with this code:</p>

<p>```ruby
def matches(compare_with)
  if compare_with.is_a?(Regexp)</p>

<pre><code>@data_string =~ compare_with
</code></pre>

<p>  else</p>

<pre><code>@data_string == compare_with
</code></pre>

<p>  end
end
```</p>

<p>I was less than thrilled. So I did what everyone does, I asked the internet.
Thanks to Twitter, specifically James Edward Gray II
<a href="https://twitter.com/jeg2">@JEG2</a> who btw completely rocks, I was pointed at
<code>===</code>. Though the documentation on <code>===</code> leaves something to be desired:</p>

<p>  <blockquote><p>Used to compare each of the items with the target in the <code>when</code> clause of<br/>  a <code>case</code> statement.</p><footer><strong>Dave Thomas, Programming Ruby 1.9, page 128</strong> <cite><a href='http://pragprog.com/book/ruby/programming-ruby'>pragprog.com/book/ruby/&hellip;</a></cite></footer></blockquote></p>

<ul>
<li>The <a href="http://ruby-doc.org/core-1.9.3/String.html#method-i-3D-3D-3D">String API</a>
sneakily directs you to <code>==</code> but doesn't outright state they are the same</li>
<li>The <a href="http://ruby-doc.org/core-1.9.3/Regexp.html#method-i-3D-3D-3D">Regexp API</a>
states it as a synonym for <a href="http://ruby-doc.org/core-1.9.3/Regexp.html#method-i-3D-7E"><code>Regexp#=~</code></a></li>
</ul>


<p>The thing to remember is with <code>case</code> when you have the following:</p>

<p><code>ruby
case thing
when other_thing
  # stuff
end
</code></p>

<p>You are just saying <code>other_thing === thing</code>. The comparison is performed with
the <code>when</code> expression as the lvalue.</p>

<p>This means I could rewrite the <code>matches</code> method as:</p>

<p><code>ruby
def matches(compare_with)
  compare_with === @data_string
end
</code></p>

<p>This also means it's possible to be more flexible on the match:</p>

<p>```ruby</p>

<h1>@data_string = "coding for fun"</h1>

<p>matches "oding"           # false
matches "coding for fun"  # true
matches /oding/           # true
matches String            # true
```</p>

<p>So, the next time you're thinking of writing some code that needs to
change based on class type or how something compares with something else, think
if a <code>case</code> statement applies. If it does, see if <code>===</code> works to produce better
code.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Everyone Should Learn metaprogramming]]></title>
    <link href="http://cupakromer.github.com/blog/2012-08-14-everyone-should-learn-meta-programming.html"/>
    <updated>2012-08-14T17:54:00-04:00</updated>
    <id>http://cupakromer.github.com/blog/everyone-should-learn-meta-programming</id>
    <content type="html"><![CDATA[<p>A few weeks ago was the first <a href="http://steelcityrubyconf.org/">Steel City Ruby conference</a>.
It was a great conference and I would highly recommend you attend next
year. While there, I had the opportunity to give my first lightning talk.</p>

<p><a href="http://www.flickr.com/photos/charliekilo/7717397572/in/photostream"><img class="right" src="/images/scrc12_lightning_talk.jpg" width="391" height="287" title="12 Lightning Talk" alt="An image of me presenting at SCRC12"></a>
Now I'm not one for public speaking, in fact it's terrifying for me.
However, the Ruby community is awesome, friendly, and very encouraging.
After thinking about it for a while, talking with several people, and
reflecting on my time participating in <a href="http://scrappyacademy.com/">Scrappy Academy</a>,
I decided that it was important to speak up about metaprogramming.</p>

<p>I titled my talk: "<em>Demystifying Metaprogramming</em>." The intent was to
encourage those people who are afraid of "metaprogramming" to give it a
try. I strongly believe if you have been programming Ruby (or Rails -
this is just Ruby with a fun web framework) for more than two months,
you owe it to yourself to learn metaprogramming.</p>

<p>To most people, this included me, they hear about "metaprogramming" as
this advanced technique that should be avoided by all but the most
wizardly among us. Frankly, this big scary stigma attached to
metaprogramming just isn't warranted.</p>

<p><span class='pullquote-right' data-pullquote='&#8220;metaprogramming&#8221; is just
programming'>
I'll let you in on the big secret, "metaprogramming" is just
programming. Yep. It's not scary. It may be a bit complicated, but at
the end of the day it is well worth your time to learn. You may even find
it to be fun.
</span></p>

<p>To help ease you into the topic, we'll start with a simple contrived
example to demonstrate that you already know everything needed to get
started.</p>

<p><code>ruby
def say( phrase )
  puts phrase
end
</code></p>

<p>Yep. That's a really basic method. It simply <code>puts</code> the object that is
passed in. To use this method in <a href="http://en.wikipedia.org/wiki/Interactive_Ruby_Shell">irb</a>
or <a href="https://github.com/pry/pry">pry</a> we could simply:</p>

<p>```ruby</p>

<blockquote><p>def say( phrase )
*  puts phrase
* end
=> nil
say "Steel City Ruby I heard you like programming."
Steel City Ruby I heard you like programming.
=> nil
```</p></blockquote>

<p>This shouldn't be anything shocking so far. In fact, all we've done is
create a method that calls a method (<code>puts</code>) and pass it a parameter. In
fact, this concept is at the heart of the "meta" programming.</p>

<p>All you really are doing is writing methods, that call another method,
and pass it a parameter. It just so happens that the parameter you pass,
tends to be a block that defines a new method.</p>

<p><blockquote><p>Write a method, that calls a method, that creates a method.*</p></blockquote></p>

<p>So to extend our example and add the "meta" part to it, we'll just:</p>

<ul>
<li>Wrap our method in another method</li>
<li>Pass our method as the parameter to another method</li>
</ul>


<p>```ruby
def just_programming
  class_eval do</p>

<pre><code>def say( phrase )
  puts phrase
end
</code></pre>

<p>  end
end
```</p>

<p>In this case, we're using the special <a href="http://www.ruby-doc.org/core-1.9.3/Module.html#method-i-class_eval"><code>class_eval</code></a>
method. In a nutshell, this will change the value of <code>self</code> and then
execute the block in this context. In our case, we provide it a block
which contains the method definition we wish to dynmically create. The
trick here is that class definitions and methods are active code. So the
call to <code>def say( phrase )</code> is run just as if we had typed it directly
in the original class definition.</p>

<p>To be able to use this in a context more familiar, we'll just wrap this
in a module. We can then <code>extend</code> that module in our class and
dynamically create our method by using our class method
<code>just_programming</code>.</p>

<p>```ruby
module Meta
  def just_programming</p>

<pre><code>class_eval do
  def say( phrase )
    puts phrase
  end
end
</code></pre>

<p>  end
end</p>

<p>class Foo
  extend Meta
  just_programming
end</p>

<p>f = Foo.new
f.say "Steel City Ruby I heard you like programming."
=> "Steel City Ruby I heard you like programming."
```</p>

<p>I hope this has helped illustrate that "metaprogramming" is only
programming. It isn't anything to be afraid of. Sure, it can get
complicated at times, but then, what code concepts beyond the bare
basics can't?</p>

<p>You owe it to yourself to learn these nifty and fun coding techniques.
They will demystify manly things you think are "magic", provide a
deeper understanding of the Ruby language, and add tools to your
belt enabling you to write better code.</p>

<p>There are many resources on these topics if you do a search.
Additionally, <a href="http://pragprog.com/">The Pragmatic Bookshelf</a> has a
good set of resources on Ruby and metaprogramming. I found the
videos series on <a href="http://pragprog.com/screencasts/v-dtrubyom/the-ruby-object-model-and-metaprogramming">The Ruby Object Model and Metaprogramming</a>
very enlightening.</p>

<p>Happy programming!</p>

<p>* Technically, this should really be "Write a method, that <em>sends a
message</em>, that creates a method." However, I wanted to emphasise the
progression and went with this version.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Travis CI Setup for Plain Old Ruby]]></title>
    <link href="http://cupakromer.github.com/blog/2012-07-18-travis-ci-setup-for-plain-old-ruby.html"/>
    <updated>2012-07-18T01:11:00-04:00</updated>
    <id>http://cupakromer.github.com/blog/travis-ci-setup-for-plain-old-ruby</id>
    <content type="html"><![CDATA[<p>I recently wanted to setup some automated testing for a mini project I
was working on. I was using regular Ruby and wanted to try working with
<a href="http://travis-ci.org/">Travis CI</a>. For public projects, this is a great <em>free</em>
resource which I cannot recommend enough.</p>

<p>They have a decent amount of <a href="http://about.travis-ci.org/docs/">documentation</a>
on how to setup your project. However, it took me longer than I thought
necessary to get a basic Ruby project configured.</p>

<p>In the end, it came down to needing three things:</p>

<ul>
<li><p>The <code>rake</code> gem present in either a <code>Gemfile</code> or <code>*.gemspec</code> file</p></li>
<li><p>A <code>.travis.yml</code> file</p></li>
</ul>


<p><code>yaml .travis.yml
language: ruby
rvm:
  - 1.9.2
  - 1.9.3
</code></p>

<ul>
<li>A <code>Rakefile</code> with a default task to run the tests</li>
</ul>


<p>```ruby Rakefile</p>

<h1>!/usr/bin/env rake</h1>

<p>require "bundler/gem_tasks"</p>

<p>require 'rspec/core/rake_task'</p>

<p>desc 'Default: Run specs.'
task default: :spec</p>

<p>desc 'Run specs'
RSpec::Core::RakeTask.new do |task|
  task.rspec_opts = "--format doc"
end
```</p>

<p>Just drop those two files into your project directory and you are ready
to experience the fun of CI.</p>
]]></content>
  </entry>
  
</feed>
