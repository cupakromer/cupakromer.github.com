<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rspec | Aaron Kromer's Blog]]></title>
  <link href="http://cupakromer.github.com/blog/categories/rspec/atom.xml" rel="self"/>
  <link href="http://cupakromer.github.com/"/>
  <updated>2014-09-29T12:12:47-04:00</updated>
  <id>http://cupakromer.github.com/</id>
  <author>
    <name><![CDATA[Aaron Kromer]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Farewell JSON API gems]]></title>
    <link href="http://cupakromer.github.com/blog/2014-09-29-farewell-json-api-gems.html"/>
    <updated>2014-09-29T11:51:00-04:00</updated>
    <id>http://cupakromer.github.com/blog/farewell-json-api-gems</id>
    <content type="html"><![CDATA[<p>In the past, testing JSON APIs tended to be a bit painful for me. Most of this
pain revolved around setting expectations on the response body.</p>

<p>If you treat the response as a raw string, attempting to use regular
expressions ends up being an exercise in how you handle frustration. While a
JSON body is a string, it has structure. Using regular expressions for parsing
them is akin to using a hammer on a screw. It'll get the job done, but it's the
wrong tool for the job.</p>

<p>Ruby gives us <a href="http://ruby-doc.org/stdlib-2.1.3/libdoc/json/rdoc/JSON.html#method-i-parse"><code>JSON.parse</code></a>.
Which will convert a valid JSON string into a more familiar object structure.
Now comes the "fun" part of actually verifying that structure:</p>

<ul>
<li>Sometimes you only care about part of the response</li>
<li>Sometimes you care about validating the entire response</li>
<li>Sometimes the response is very complicated consisting of many smaller, more
logically meaningful, structures</li>
<li>Sometimes you only care about the general structure (e.g. this value must be
a number, that value must be either an empty array or an array of strings,
etc.)</li>
</ul>


<p>It is possible to do all of these validations out of the box. In my experience,
writing them tended to be tedious. Often the resulting code left something to
be desired in terms of readability. This was especially true when validating the
general response structure.</p>

<p>I like to follow the "one expectation per spec" guideline. However, this lead
to writing many small specs. Normally, this is perfectly fine and something I
advocate you do. However, in terms of a JSON response, it means I need to have
more discipline to keep everything explicitly organized.</p>

<p>Naturally in the Ruby community, many gems have sprouted up to help with this
problem set. I've had a bit of success with some of those gems in the past.
However, with the release of RSpec 3, <a href="http://myronmars.to/n/dev-blog/2014/01/new-in-rspec-3-composable-matchers">several new
features</a>
have eliminated my need for these JSON gems.</p>

<p>Expectations on a JSON response is a great fit for <a href="https://www.relishapp.com/rspec/rspec-expectations/v/3-0/docs/composing-matchers">composing
matchers</a>.
When I need to logically group checking several options, the <a href="https://www.relishapp.com/rspec/rspec-expectations/v/3-0/docs/compound-expectations">compound matchers</a>
are the perfect tool.</p>

<p>Often people don't realize that the matcher messages (i.e. <code>exist</code>, <code>be</code>, <code>eq</code>,
<code>include</code>, etc) are just factories. They are just helper methods which create
the matcher object for you. That means, we can easily write our own using our
app's domain language.</p>

<p>Let's jump right into an example!</p>

<p>These examples are assuming a JSON structure like one of the ones listed on the
<a href="http://jsonapi.org/format/#document-structure-compound-documents">jsonapi.org</a>
site. Though I am assuming integer value are represented as numbers and not
strings, since that is valid JSON and more meaningful:</p>

<p>```ruby</p>

<h1>Use common JSON helpers such as: <code>json_response</code>, <code>be_an_empty</code>, <code>all_match</code></h1>

<p>require 'support/json_api_helpers'</p>

<p>def be_kits_root_json
  be_kits_json.and(</p>

<pre><code>include(
  'meta' =&gt; {
    'first'   =&gt; anything,
    'last'    =&gt; anything,
    'current' =&gt; anything,
  }
)
</code></pre>

<p>  )
end</p>

<p>def be_kits_json
  include(</p>

<pre><code>'version' =&gt; '1.0',
'links'   =&gt; {
  'kits.beacons'       =&gt; "#{beacons_url}/{kits.beacons}",
  'kits.overlays'      =&gt; "#{overlays_url}/{kits.overlays}",
  'beacons.attributes' =&gt; "#{beacon_attributes_url}/{beacons.attributes}",
},
'kits'    =&gt; be_an_empty(Array).or(
  all_match(
    'id'        =&gt; Fixnum,
    'name'      =&gt; be_nil.or(be_a String),
    'api_token' =&gt; String,
    'account'   =&gt; be_nil.or(
      match(
        'id'   =&gt; Fixnum,
        'name' =&gt; be_nil.or(be_a String),
      )
    ),
    'links'     =&gt; {
      'self'     =&gt; /\A#{kits_url}\/\d+\z/,
      'beacons'  =&gt; be_an_empty(Array).or(all be_a Fixnum),
      'overlays' =&gt; be_an_empty(Array).or(all be_a Fixnum),
    },
  ),
),
</code></pre>

<p>  )
end</p>

<p>def include_linked_resources(*resources)
  resource_maps = resources.each_with_object({}) { |resource, mappings|</p>

<pre><code>mappings.store(resource.to_s, be_an(Array))
</code></pre>

<p>  }
  include('linked' => resource_maps)
end</p>

<p>context "a basic user", "with a kit having no beacons or maps" do
  # Setup world state</p>

<p>  describe "requesting the kits root" do</p>

<pre><code>it "conforms to the expected JSON structure" do
  get kits_path, *options
  expect(json_response).to be_kits_root_json
end

# More specific specs
</code></pre>

<p>  end</p>

<p>  describe "requesting a kit" do</p>

<pre><code>it "conforms to the expected JSON structure" do
  get kit_path(kit), *options
  expect(json_response).to be_kits_json
end

# More specific specs
</code></pre>

<p>  end
end</p>

<h1>More state specs</h1>

<p>context "a developer user", "sending request with parameter 'include'" do
  # Setup world state</p>

<p>  describe "requesting the kits root" do</p>

<pre><code>it "conforms to the expected JSON structure with included resources" do
  get kits_path(include: "beacons,beacon_attributes"), *options
  expect(json_response).to be_kits_root_json.and(
    include_linked_resources(:beacons, :beacon_attributes)
  )
end
</code></pre>

<p>  end</p>

<p>  describe "requesting a beacon" do</p>

<pre><code>it "conforms to the expected JSON structure with included resources" do
  get kit_path(kit, include: "beacons,beacon_attributes"), *options
  expect(json_response).to be_kits_json.and(
    include_linked_resources(:beacons, :beacon_attributes)
  )
end
</code></pre>

<p>  end
end
```</p>

<p>The possibilities are fairly endless. We could improve this further by allowing
the factories to take model instances or attribute hashes. We can use those to
check specific content when available:</p>

<p>```ruby
def account_resource(account = nil, allow_nil: false)
  return nil unless account || !allow_nil
  if account</p>

<pre><code>{
  'id'   =&gt; account.id,
  'name' =&gt; account.name
}
</code></pre>

<p>  else</p>

<pre><code>{
  'id'   =&gt; Fixnum,
  'name' =&gt; be_nil.or(be_a String),
}
</code></pre>

<p>  end
end</p>

<p>def kit_resource(kit = nil, allow_nil: false)
  return nil unless kit || !allow_nil
  if kit</p>

<pre><code>{
  'id'        =&gt; kit.id,
  'name'      =&gt; kit.name,
  'api_token' =&gt; kit.api_token,
  'account'   =&gt; account_resource(kit.account, allow_nil: true),
}
</code></pre>

<p>  else</p>

<pre><code>{
  'id'        =&gt; Fixnum,
  'name'      =&gt; be_nil.or(be_a String),
  'api_token' =&gt; String,
  'account'   =&gt; be_nil.or(match account_resource),
}
</code></pre>

<p>  end
end</p>

<p>context "a basic user", "with a kit having no beacons or maps" do
  # Setup world state</p>

<p>  describe "requesting the kits root" do</p>

<pre><code>it "conforms to the expected JSON structure" do
  get kits_path, *options
  expect(json_response).to be_kits_root_json
end

it "has only the expected kit" do
  get kits_path, *options
  expect(json_response).to include 'kits' =&gt; [kit_resource(basic_users_kit)]
end
</code></pre>

<p>  end</p>

<p>  describe "requesting a beacon" do</p>

<pre><code>it "conforms to the expected JSON structure" do
  get kit_path(kit), *options
  expect(json_response).to be_kits_json(basic_users_kit)
end
</code></pre>

<p>  end
end
```</p>

<p>Happy RSpec'ing!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Monitoring Specific Messages in RSpec Part 3]]></title>
    <link href="http://cupakromer.github.com/blog/2013-07-26-monitoring-specific-messages-in-rspec-part-3.html"/>
    <updated>2013-07-26T10:13:00-04:00</updated>
    <id>http://cupakromer.github.com/blog/monitoring-specific-messages-in-rspec-part-3</id>
    <content type="html"><![CDATA[<p>File /Users/aaron/dev/cupakromer/cupakromer.github.com/source/<em>posts/</em>monitor_specific_messages_posts.md could not be found</p>

<p>Continuing the series (
<a href="http://aaronkromer.com/blog/2013-07-17-monitoring-specific-messages-in-rspec.html">part 1</a>,
<a href="http://aaronkromer.com/blog/2013-07-24-monitoring-specific-messages-in-rspec-part-2.html">part 2</a>
) on matching messages in RSpec, the next logical step is custom argument
matchers.</p>

<p><code>ruby
expect(mechanic).to receive(:fix).with something_broken
</code></p>

<p>Using the RSpec <a href="https://www.relishapp.com/rspec/rspec-expectations/v/2-14/docs/custom-matchers">matcher DSL</a>
this could simply look like:</p>

<p>```ruby
RSpec::Matchers.define :something_broken do
  match do |thing|</p>

<pre><code>thing.broken?
</code></pre>

<p>  end
end
```</p>

<p>That's all there is to it. Now it can be used as both a regular matcher and as
an argument matcher.</p>

<p>If the matcher needs to be created from
<a href="http://rubydoc.info/gems/rspec-expectations/RSpec/Matchers">scratch</a>, a
<code>matches?</code> method must be defined instead:</p>

<p>```ruby
class SomethingBroken
  def matches?(target)</p>

<pre><code>target.broken?
</code></pre>

<p>  end
end</p>

<p>def something_broken
  SomethingBroken.new
end
```</p>

<p>This works just fine as a normal matcher, however, when used as an argument
matcher, it will always fail. The reason is that argument matchers are invoked
with the <code>==</code> operator, which by <a href="http://ruby-doc.org/core-2.0/BasicObject.html#method-i-3D-3D">default</a>,
verifies if the objects are the same object.</p>

<p>Attempting to use a normal matcher with the
<a href="https://www.relishapp.com/rspec/rspec-expectations/v/2-14/docs/built-in-matchers/expect-change"><code>change</code></a>
expectation also
<a href="https://github.com/rspec/rspec-expectations/issues/276">oddly</a> fails, due to
<code>change</code> invoking the
<a href="http://aaronkromer.com/blog/2012-10-12-equals-equals-equals-the-forgotten-equality.html"><code>===</code></a>
message, not <code>matches?</code>. Since the <a href="http://ruby-doc.org/core-2.0/Object.html#method-i-3D-3D-3D">default <code>===</code> behavior is
<code>==</code></a>, the existing
argument matchers currently work with it.</p>

<p>There is active talk / changes
<a href="https://github.com/rspec/rspec-expectations/issues/280">happening</a> to
standardize the matchers to <code>===</code>. This will allow for a more consistent and
composable interface. It also has the added benefit of allowing the matchers to
be used in more complex conditionals using <code>case</code> statements.</p>

<p>To fix the class based matcher simply add the necessary alias(es):</p>

<p>```ruby
class SomethingBroken
  def matches?(target)</p>

<pre><code>target.broken?
</code></pre>

<p>  end
  alias_method :==, :matches?
  alias_method :===, :matches?  # Not technically necessary due to default ==
end
```</p>

<p>Note that with such a simple matcher, there is no reason it cannot be created
as a simple composed method using an existing matcher:</p>

<p><code>ruby
def something_broken
  be_broken   # Note: Not all built in matchers have == aliases yet
end
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Monitoring Specific Messages in RSpec Part 2]]></title>
    <link href="http://cupakromer.github.com/blog/2013-07-24-monitoring-specific-messages-in-rspec-part-2.html"/>
    <updated>2013-07-24T10:11:00-04:00</updated>
    <id>http://cupakromer.github.com/blog/monitoring-specific-messages-in-rspec-part-2</id>
    <content type="html"><![CDATA[<p>File /Users/aaron/dev/cupakromer/cupakromer.github.com/source/<em>posts/</em>monitor_specific_messages_posts.md could not be found</p>

<p><a href="http://aaronkromer.com/blog/2013-07-17-monitoring-specific-messages-in-rspec.html">Last time</a> it was demonstrated how it is possible to monitor only a desired
message expectations. While that technique is useful for a vast majority of
use cases, sometimes you need a bit more complexity.</p>

<p>Say for example, the desire is to verify the state of the provided parameter.
As in this very contrived example (<em>Update: 2013-07-28 Paired down example to
only show test and not implementation</em>):</p>

<p>```ruby
describe Factory do
  context 'making sure current stock is ready' do</p>

<pre><code>it 'only fixes broken widgets' do
  # Setup code

  states = []
  expect(mechanic).to receive(:fix) do |widget|
    states &lt;&lt; widget.broken?
  end

  expect{ factory.perform_maintenance }.to change{states}.to [true]
end
</code></pre>

<p>  end
end
```</p>

<p>This leverages the <a href="https://www.relishapp.com/rspec/rspec-mocks/v/2-14/docs/method-stubs/stub-with-substitute-implementation">stub with substitute implementation</a>
provided by RSpec mocks. It can also be used with the <code>allow</code> syntax.</p>

<p>While the above version has it's uses, it tends to hide some of the intent in
the closure manipulation. A slightly more expressive method is just to add
the state expectation in the block:</p>

<p><code>ruby
expect(mechanic).to receive(:fix) do |widget|
  expect(widget).to be_broken
end
</code></p>

<p>This last technique is great for setting up generic message stubs which require
that something with specific state is provided. By adding it to a generic
<code>allow</code>, it ensures when the contract is broken anywhere in the code under test,
the test will properly fail. (<em>Update 2013-07-30: seems there is an
<a href="https://github.com/rspec/rspec-mocks/pull/382">issue</a> with this technique when
combined with
<a href="https://www.relishapp.com/rspec/rspec-mocks/v/2-14/docs/message-expectations/calling-the-original-method"><code>and_call_original</code></a></em>)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Monitoring Specific Messages in RSpec]]></title>
    <link href="http://cupakromer.github.com/blog/2013-07-17-monitoring-specific-messages-in-rspec.html"/>
    <updated>2013-07-17T11:34:00-04:00</updated>
    <id>http://cupakromer.github.com/blog/monitoring-specific-messages-in-rspec</id>
    <content type="html"><![CDATA[<p>File /Users/aaron/dev/cupakromer/cupakromer.github.com/source/<em>posts/</em>monitor_specific_messages_posts.md could not be found</p>

<p>A common question I see asked in the #rspec IRC channel is:</p>

<blockquote><p>How do I verify only a specific message is received?</p></blockquote>

<p>The context of this question is usually a method that sends the same message
multiple time, but with different arguments.</p>

<p>Take the following contrived example:</p>

<p>```ruby
def do_stuff(thing)
  thing.do :having_fun
  thing.do :drink_coffee
  thing.do :code
end</p>

<p>describe 'Coffee time!' do
  it 'drinks the coffee' do</p>

<pre><code>thing = double('Thing')

expect(thing).to receive(:do).with(:drink_coffee)

do_stuff thing
</code></pre>

<p>  end
end
```</p>

<p>Alas, it fails:</p>

<p>```text
Double "Thing" received :do with unexpected arguments</p>

<pre><code>     expected: (:drink_coffee)
          got: (:having_fun)
</code></pre>

<p>```</p>

<p>The solution is to add a generic stub (a catchall) for the desired message:</p>

<p>```ruby
describe 'Coffee time!' do
  it 'drinks the coffee' do</p>

<pre><code>thing = double('Thing')

allow(thing).to receive(:do)
expect(thing).to receive(:do).with(:drink_coffee)

do_stuff thing
</code></pre>

<p>  end
end
```</p>

<p>There is another solution which can also be used:
<a href="https://www.relishapp.com/rspec/rspec-mocks/v/2-14/docs/method-stubs/as-null-object"><code>as_null_object</code></a>.</p>

<p>The issue with <code>as_null_object</code> is that it will happily hum along even for
invalid and unexpected messages. The double stub pattern above is
explicit in the test, matching the catchall only with the message expectation.</p>

<p>```ruby
describe 'Coffee time!' do
  it 'drinks the coffee' do</p>

<pre><code>thing = double('Thing').as_null_object

expect(thing).to receive(:do).with(:drink_coffee)

do_stuff thing
</code></pre>

<p>  end
end
```</p>

<p>Stay tuned for <a href="http://myronmars.to/n/dev-blog/2013/07/the-plan-for-rspec-3">RSpec3</a>
when <code>as_null_object</code> doubles will be smart enough to only stub matching
messages.  Or check out one of the many plugins:
<a href="https://github.com/xaviershay/rspec-fire"><code>rspec-fire</code></a>,
<a href="https://github.com/psyho/bogus"><code>bogus</code></a>, and
<a href="https://github.com/ryanong/spy"><code>spy</code></a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Bang is for Surprise]]></title>
    <link href="http://cupakromer.github.com/blog/2013-05-19-the-bang-is-for-surprise.html"/>
    <updated>2013-05-19T21:20:00-04:00</updated>
    <id>http://cupakromer.github.com/blog/the-bang-is-for-surprise</id>
    <content type="html"><![CDATA[<p><strong><em>Note:</em></strong> I'm using Ruby 2.0.0 and RSpec 2.13.1 for these samples. Behavior
may be slightly different in older versions. YMMV!</p>

<p>One of the more well known features of <a href="github.com/rspec/rspec-core">RSpec</a> is
<a href="https://www.relishapp.com/rspec/rspec-core/v/2-13/docs/helper-methods/let-and-let!"><code>let</code></a>.
It provides a way to create a variable as a
<a href="http://devblog.avdi.org/2012/10/01/barewords/">bareword</a> which is lazy loaded
and memoized.</p>

<p>It also has a sibling <code>let!</code>. On the surface, <code>let!</code> is just a <code>let</code> without
the lazy loading. So any variable defined with a <code>let!</code> will always be created
before a test. This tool has a few nuances that should be know before you reach
for it.</p>

<p>Take the following sample. <em>What do you think the result will be?</em></p>

<p>```ruby
describe "Which one wins?" do</p>

<p>  let!(:sample) { "using let bang!" }</p>

<p>  context "inside a context" do</p>

<pre><code>let(:sample) { "normal let" }

it { expect(sample).to eq "normal let" }
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>The test passes. This may or may not have been surprising. The rules for nested
<code>let</code>s, is that the <code>let</code> defined closet to the test in the hierarchy wins.
But, didn't I say <code>let!</code> always created the object which was then memoized?</p>

<p>I'll get to more about how <code>let</code> and <code>let!</code> are implemented in a minute. For
now, I want to point out a subtle surprise waiting for you; or possibly bring
to light that nagging itch at the back of your brain.</p>

<p>```ruby
describe "Using Conflicting Let and Let!" do</p>

<p>  let!(:user) { create :user, name: 'bob' }</p>

<p>  # LOTS OF CODE SO YOU CAN'T SEE THE ABOVE LINE</p>

<p>  context "inside a context" do</p>

<pre><code>let(:user) { create :user, name: 'alice' }

# Will this pass?
it do
  expect(User.count).to eq 0
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Surprise! The test fails:</p>

<p>```text
  1) Which one wins? inside a context</p>

<pre><code> Failure/Error: expect(User.count).to eq 0

   expected: 0
        got: 1

   (compared using ==)
</code></pre>

<p>```</p>

<p><a href="https://www.destroyallsoftware.com/talks/wat"><strong>WAT?</strong></a></p>

<p><code>user</code> was never explicitly referenced in our test or a <code>before</code> block. Above I
also stated that the <code>let</code> closest to the test <em>wins</em>. Theoretically, by these
rules one would naturally think the test would have passed. Yet, someone was
created in the database.</p>

<p><em>Which user definition do you think was created?</em></p>

<p>If we dump the <code>User</code> collection before the <code>expect</code> line we see:</p>

<p><code>ruby
[&lt;User id: 1, name: "alice", ...&gt;]
</code></p>

<p>Not only did the inner normal <code>let</code> block appear to override the outer, the
outer <code>let!</code> behavior took affect!</p>

<p>Let's try one more:</p>

<p>```ruby
describe "Using Conflicting Nested Let!" do</p>

<p>  let!(:user) { create :user, name: 'bob' }</p>

<p>  context "inside a context" do</p>

<pre><code># Now we'll use the bang version here
let!(:user) { create :user, name: 'alice' }

# Will this pass?
it do
  expect(User.count).to eq 1
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Surprise! It passes:</p>

<p>```text
Using Conflicting Nested Let!
  inside a context</p>

<pre><code>should eq 1
</code></pre>

<p>Finished in 0.02185 seconds
1 example, 0 failures
```</p>

<p>Again, dumping the user created we see our good friend Alice:</p>

<p><code>ruby
[&lt;User id: 1, name: "alice", ...&gt;]
</code></p>

<p>If you're scratching your brain right now. Don't worry. I did too the first
time.  However, once we cover what is happening behind that curtain things will
make perfect sense.</p>

<h2>How <code>let</code> and <code>let!</code> Work</h2>

<p>"<strong><em>Pay <del>[no]</del> attention</em></strong> to that man behind the curtain!"
- <a href="http://en.wikiquote.org/wiki/The_Wizard_of_Oz#The_Wizard">The Wizard</a></p>

<p>The reason for this behavior, remember I'm using RSpec 2.13, is that <code>let!</code>
just calls <code>let</code> and <code>before</code> <a href="https://github.com/rspec/rspec-core/blob/5baa615d/lib/rspec/core/memoized_helpers.rb#L257">behind the scenes</a>:</p>

<p><code>ruby
def let!(name, &amp;block)
  let(name, &amp;block)
  before { __send__(name) }
end
</code></p>

<p>And all
<a href="https://github.com/rspec/rspec-core/blob/5baa615d/lib/rspec/core/memoized_helpers.rb#L195"><code>let</code></a>
does is setup a memoized method based on the name and provided block:</p>

<p>```ruby
MemoizedHelpers.module_for(self).send(:define_method, name, &amp;block)</p>

<p>define_method(name) do
  <strong>memoized.fetch(name) { |k| </strong>memoized[k] = super(&amp;nil) }
end
```</p>

<h3><em>"Using Conflicting Let and Let!"</em> Explained</h3>

<p>Going back to the example <em>"Using Conflicting Let and Let!"</em> above, where both
<code>let!</code> and <code>let</code> were used. It should be a bit clearer what is really going on.</p>

<p>When the test runs, the <code>let!</code> has already created the <code>before</code> block, which
will send the message <code>:user</code>. However, the inner context's <code>let</code> created a new
method with the same name. Thus based on standard Ruby method lookup, when the
<code>before</code> block runs the inner method receives the message:</p>

<p>```ruby
describe "Using Conflicting Let and Let!" do</p>

<p>  # Expanding the following out:
  # let!(:user) { create :user, name: 'bob' }
  def user</p>

<pre><code>create :user, name: 'bob'
</code></pre>

<p>  end
  before{ user }</p>

<p>  context "inside a context" do</p>

<pre><code># Expanding the following out:
# let(:user) { create :user, name: 'alice' }
def user
  create :user, name: 'alice'
end

# The outer `before` block will run before this example.
# Due to the examples being objects, the inner
# `def user` will receive the `:user` message sent
# by `before`.
it do
  expect(User.count).to eq 0
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<h3><em>"Using Conflicting Nested Let!"</em> Explained</h3>

<p>It should also start to make sense what was going on with the <em>"Using
Conflicting Nested Let!"</em> example:</p>

<p>```ruby
describe "Using Conflicting Nested Let!" do</p>

<p>  # Expanding the following out:
  # let!(:user) { create :user, name: 'bob' }
  def user</p>

<pre><code>create :user, name: 'bob'
</code></pre>

<p>  end
  before{ user }</p>

<p>  context "inside a context" do</p>

<pre><code># Now we'll use the bang version here
# Expanding the following out:
# let!(:user) { create :user, name: 'alice' }
def user
  create :user, name: 'alice'
end
before{ user }

# The outer `before` block will run before this example.
# Due to the examples being objects, the inner
# `def user` will receive the `:user` message sent
# by the outer `before`.
#
# The inner `before` block will run next, also sending
# the message `:user`. This is also received by the
# inner example object. However, since `let` is also
# memoized, this doesn't actually execute the `:create`.
# It just returns the already created object.
it do
  expect(User.count).to eq 1
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<h3>It's Just a Method</h3>

<p>I hope that helps demystify the behavior.</p>

<p>Since <code>let</code> is just a helper for setting up methods on the <a href="http://interblah.net/how-rspec-works">example group object</a>
you can call <code>super</code> in it; though this is generally not an advised practice.</p>

<p>```ruby
describe "Just a Method" do</p>

<p>  let!(:sample) { "using let bang!" }</p>

<p>  context "using super()" do</p>

<pre><code>let(:sample) {
  p super()
  "normal let"
}

it { expect(sample).to eq "normal let" }
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>```text
Just a Method
  using super()
"using let bang!"</p>

<pre><code>should eq "normal let"
</code></pre>

<p>```</p>

<h2>Avoiding Ambiguity</h2>

<p>Since that tiny little <code>!</code> can be hard to see, especially in a sea of <code>let</code>
declarations, it is easy to miss it and get surprised. Additionally, seeing as
how mixing <code>let!</code> and <code>let</code> can lead to some surprises, it's fairly clear why
<code>let!</code> has started, rightly so in my opinion, to fall out of favor with some of
the RSpec crowd.</p>

<p>Luckily, there should be very few situations you should find yourself in where
you want to reach for <code>let!</code> over <code>let</code>. For me, this is usually a situation
where I'm creating some sort of persisted resource. For instance, the factory
example, or creating a test file on the system.</p>

<h2>Options For Preloading</h2>

<p>If people are moving away from using <code>let!</code>, how should you preload variables?</p>

<h3>Reference in <code>before</code></h3>

<p>Call them just like RSpec does in a <code>before</code>:</p>

<p>```ruby
let(:bob)   { create :user, name: 'bob'   }
let(:alice) { create :user, name: 'alice' }</p>

<p>before do
  bob
  alice
end
```</p>

<p>To me this looks a bit odd. People I've talked to tend to have two reactions:</p>

<ol>
<li>Why are you referencing a <em>'variable'</em> and not using it?</li>
<li>Wouldn't it be a bit more explicit to show the creation using an <code>@var</code>?</li>
</ol>


<p>By now you should know that the first response indicates a lack of understand on
how RSpec works. They aren't variables, they are actually bareword messages.</p>

<p>The second response is a valid point. The result would be:</p>

<p><code>ruby
before do
  @bob   = create :user, name: 'bob'
  @alice = create :user, name: 'alice'
end
</code></p>

<p>This goes back to preference and style. My preference is to reach for a
bareword whenever I can. One reason is that, when using an instance variables
you are now locked in to how both <code>@bob</code> and <code>@alice</code> are created. If you later
wanted to modify them, you could but at the expense of already having created
the persisted resource; remember <code>before</code> blocks execute outside-in (this isn't
so much of an issue for lightweight objects). Or you have to roll your own
memoization scheme (not hard just duplication of work).</p>

<h3>Use a method</h3>

<p>The next common thing I see done is people say: <em>"I'll just wrap it all up in a
method."</em></p>

<p>```ruby
def create_users
  @bob   = create :user, name: 'bob'
  @alice = create :user, name: 'alice'
end</p>

<p>before { create_users }
```</p>

<p>Now the <code>before</code> looks better; it's explicit what is happening. However, the
new <code>create_users</code> method looks just like our old <code>before</code>. So this really just
added one level of indirection.  The main advantage here is if we need to
change the behavior we can just write a new <code>create_users</code> method in an inner
context. We could also use barewords by making our variables into methods:</p>

<p>```ruby
def bob
  @bob ||= create :user, name: 'bob'
end</p>

<p>def alice
  @alice ||= create :user, name: 'alice'
end</p>

<p>def create_users
  bob
  alice
end</p>

<p>before { create_users }
```</p>

<p>Though now we've duplicated the lazy loading and memoizing logic already
provided by <code>let</code>.</p>

<p>At this point, you'll probably say, we can make this a bit more explicit and
clean it up at the same time:</p>

<p>```ruby
def bob
  @bob ||= create :user, name: 'bob'
end</p>

<p>def alice
  @alice ||= create :user, name: 'alice'
end</p>

<p>def create_users(*users)
  users.each{ |user| public_send user }
end</p>

<p>before { create_users :bob, :alice }
```</p>

<p>This brings me to my next option.</p>

<h3>Explicit Preload</h3>

<p>Now there's nothing inherently wrong with the above methods. However, to me
they add a lot of work, without adding much additional value. There are still
cases where I'll break out the generator method as it's a very useful tool. But
this section is about another option, so I'll get to it.</p>

<p>Having gone through the cycle of improvement the <em>"hard"</em> way, it's time to
show you the shortcut. To me, this is reminiscent of high school calculus
class where the teacher made me do everything the difficult, time consuming
way, for a week before teaching how it's usually done with the shorter method.</p>

<p>Since pretty much everything in RSpec is already just a method, we can leverage
that to get our desired behavior. This was discussed in a <a href="https://github.com/rspec/rspec-core/pull/815#issuecomment-14446077">pull request</a>:</p>

<p>```ruby
module LetPreloadable
  def preload(*names)</p>

<pre><code>before do
  names.each { |name| __send__ name }
end
</code></pre>

<p>  end
end</p>

<p>RSpec.configure do |rspec|
  rspec.extend LetPreloadable
end
```</p>

<p>You can place the module code anywhere you want (usually in <code>spec/support</code>).
Then you'll load it in a <code>RSpec.configure</code> block either in the same file or in
<code>spec_helper.rb</code>.</p>

<p>Our setup now looks like:</p>

<p>```ruby
let(:bob)   { create :user, name: 'bob'   }
let(:alice) { create :user, name: 'alice' }</p>

<p>preload :bob, :alice
```</p>

<p>Going back to our original example. There is now more context to what is
happening without the confusing mix of <code>let</code> and <code>let!</code>:</p>

<p>```ruby
describe "No More Conflicting Let and Let!" do</p>

<p>  let(:user) { create :user, name: 'bob' }</p>

<p>  preload :user</p>

<p>  context "inside a context" do</p>

<pre><code>let(:user) { create :user, name: 'alice' }

it do
  expect(User.count).to eq 1
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<h2>Introducing <a href="https://github.com/cupakromer/conjurer"><code>Conjurer</code></a> Gem</h2>

<p>I've started using this in enough new projects that I wanted an easy way to
just add it. I also wanted to be able to include any changes easily. Thus, I've
rolled it all up into a gem: <a href="http://rubygems.org/gems/conjurer"><code>conjurer</code></a></p>

<p><strong>Happy RSpecing!!</strong></p>
]]></content>
  </entry>
  
</feed>
